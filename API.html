<html>

<head>
<meta charset="utf-8">
</head>
<body>
ВИДЕО REST API<br>
<br>
апи - это официант(посредник)между клиентом(кто пользуется услугами) и кухней (провайдер(сервер) - предосталяет какие-то услуги) <br>
общение идет по контракту, который описывает , как клиент может обращаться к провайдеру, и какие ответы в случае запроса провайдер может дать<br>
апи это интерфейс общения между 2 независимыми компонентами ПО (фронта и бэка \ клиента и сервера )<br>
<br>
xml  -передает документ(xml -документ, + xsd файл + wsdl файл)<br>
json - все остальное <br>
json - короче, быстрее читать и писать<br>
json - состоит из пар: ключ - значение<br>
джейсон - данные в нем весят меньше(меньше текста) <br>
хранение данных в процессе их передачи <br>
текстовый формат обмена данными между клиентом и сервером<br>
в качестве значения может быть: объект, Массив, Число(1,-1,1.1), тру фолс нулл, Строка<br>
<br>
<br>
<br>
Виды АПИ:<br>
- открытые(публичные) - любой может использовать(гугл мэпс), к ним можно подключить свой проект бесплатно<br>
- партнерские-нужно заключить договор с компанией, которая владеет этим АПИ, апи является конечным продуктом<br>
- внутренние - не является конечным продуктом,используются для внутреннего использования<br>
<br>
<br>
<br>
рест - архитектурный стиль , строится на принципах:<br>
-унифицированный интерфейс - общие принципы построения путей общения , как осуществляется запрос, какие виды ответов могут быть<br>
(если используется несколько АПИ в приложении )<br>
-клиент-сервер(они обособленны, у каждого свои функции)<br>
-stateless - сервер не хранит клиентскую информацию<br>
когда клиент делает запрос на сервер, то запрос должен содержать все необходимое для того, чтобы сервер мог ответить<br>
Сервер отправляет эти данные на клиент и они сохраняются в cookies, запросом от клиента на сервер отправляются cookies<br>
- ресурс может быть кэширован,если ресурс может быть кеширован, то он должен сообщить об этом клиенту (с помощью хедеров)<br>
- система состоит из слоев, каждый слой не должен знать, что происходит в другом слое, но при этом они должны общаться между собой <br>
- передавать только ту информацию, которую запросил клиент  (загружается не весь сайт, а только страница(ресурс) ,которую запросил клиент)  <br>
- передача данныс с помощью http\https протокола<br>
-Используются разные типы данных для передачи информации(XML,JSON),можно передавать файл или текст <br>
работает на самом высоком уровне, поверх HTTP(надстройка) 
)<br>
-юзер через мобилу, десктоп выходит в интернет делает запрос(на авторизацию)<br>
-апи запрос идет на сервер(апи скрипты в процессе трансформируются в http запрос, который обрабатывается на сервере) , <br>
где осуществляется запрос (селект)в бд, идет проверка есть ли такой юзер в бд <br>
-если такой юзер найден сервер отправляет апи ответ на клиент <br>
<br>
<br>
<br>
SOAP(стандарт) - набор правил, по которым взаимодейсвуют одна программа с другой.<br>
Имеет:<br>
XML(нужен для хранения и передачи данных) - документ, сами данные.<br>
В отличии от HTML(оформление данных) XML это описание данных.Также в отличии от HTML можно добавлять свои тэги.(тэги HTML тоже можно использовать)<br>
XSD-файл - описывает структуру XML - документа и типы данных, которые могут там хранится. xsd:element name="name" type="xsd:string"<br>
WSDL-файл(структура вэб-сервиса) - описывает сообщения, заголовки,события,роуты (не нужна дока)<br>
Использует только XML<br>
Использует все протоколы прикладного уровня(HTTP,FTP,SMTP,DNS и др)<br>
Комментарий:<br>
рест - вызываем функционал исходя из метода и адреса<br>
соап - какой функционал будет выполнен на сервере, зависит от того, что находится в теле (сама операция <br>
находится в теле) - используется пост запрос, т.к. есть тело, мы всегда шлем в теле, что нужно сделать <br>
плюс соапа, что всегда весь список вэб-сервисов прописан файле wsdl (есть список всех запросов)<br>
<br>
<br>
Best practices АПИ<br>
1.эндпойнты  - существительное в ед \ множ числе /users/123, /users/123/car/2<br>
эндпойнт - часть адресной строки, которая идет после порта \users\6 <br>
Можно обращаться к нему разными методами ( \users\6) <br>
2. Использовать корректные методы + не разрешать юзерам использовать ненужные им методы ( в эндпойнте <br>
получения информации с сервера не прописывать возможность POST - метода )<br>
Если нужно что-то добавить, то добавляем еще метод\методы<br>
<br>
3.использование стандартных http-кодов (400, 500 и т д)<br>
4.Валидация - проверка на валидные данные ( на стороне фронта, бэка, бд )<br>
фронт - будет сообщение, что данные невалидны<br>
бек - тест через апи (пример:запрос на максимум\минимум символов, обязательные поля\необязательные - заполнить<br>
 те и другие и затестить, стучимся на адрем которого нет на серваке-возвращает ли 404)<br>
бд - определяется заранее, какие данные могут быть записаны в таблицу(ячейку)<br>
5. отдавать правильный статус код , описывать корректно ошибку <br>
6.всегда думать о безопасности ( https)<br>
аутентификация и авторизация <br>
нужно убедиться , что jwt токен не содержит никаких клиентских данных<br>
ограничение запросов с одного ip(чтобы не было дос атак)<br>
7. документация<br>
<br>
<br>
<br>
Тестирование АПИ<br>
тест апи относится к интеграционному тестированию(блэк бокс или вайт бокс )<br>
Плюсы АПИ Тестирования<br>
- раннее тестирование, до фронта (обычно начинают делать сначала апи и бэк)<br>
- быстрее тесты, чем на ui<br>
- проверка бизнес-логики(валидация и т д )<br>
- автотесты <br>
<br>
<br>
<br>
Процесс тестирование АПИ <br>
тест- план<br>
анализ тестов и тест-дизайн<br>
выполнение тестов <br>
регистрация багов(не те ответы, не та инфа в теле ответа)<br>
<br>
<br>
<br>
Типы тестов АПИ <br>
1.функциональное<br>
- положительные сценарии (валидные данные, верные статус коды, верные ответы в теле, в приложении просходят те изменение которые мы ожидаем)<br>
- негативные сценарии(адекватное реагирование на запросы которые сервер не ожидает, адекватный ответ при падении БД)<br>
2.нефункциональное: <br>
-нагрузочное  - Jmeter, проверка на то , что нет утечки ресурсов, они восстанавливаются после каждого запроса на сервер <br>
-безопасности - не передаем sensitive инфу ы открытом виде, sql иньекции не выполняются на уровне БД<br>
-документации - целевое назначение каждого эндпойнта, какие действия можно совершить, какие методы могут быть использованы, ожидаемые хэдеры,<br>
валидное тело запроса, тело ответа, ответ в случае ошибки.<br>
-регресс<br>
<br>
<br>
<br>
Тестовый сценарий<br>
-базовый позитивный кейс(минимальный набор данных , которые должен содержать запрос)<br>
- расширяем базовый позитивный тест с опциональными параметрами(необязательные поля на фронте)<br>
- негативыне тесты с валиднными данными(повтор уникального имени)<br>
- негативные тесты с невалидными данными<br>
- тест , что может сделать аутентифицированный и авторизированный юзер, и что может сделать неаутен и не авториз юзер(верные статус коды)<br>
- тест безопасности(описано выше)<br>
- тест нагрузочный <br>
- тест документации<br>
<br>
<br>
<br>
Основные проверки АПИ (на уровне каждого теста)<br>
- статус код <br>
- ответ<br>
- хедеры<br>
- время обработки запроса(200-500 мс)<br>
- приложение меняет свое состояние так, как мы ожидали<br>
- безопасность<br>
<br>
<br>
<br>
АПИ имеет свой порт <br>
гет запрос имеет ограничение в 2000 символов, если квери параметры больше 2000 символов , то для получения данных с сервера <br>
можно использовать пост - запрос, тело не имеет ограничений<br>
<br>
<br>
<br>
гет запрос кэширует страницу, которую мы получили с его помощью и при том же запросе берет ее из кэша браузера , это уменьшает нагрузку на сервер,<br> 
чтобы серверу каждый раз не отправлять данные на клиент <br>
<br>
<br>
<br>
<br>
Постман <br>
workspace - хранятся коллекции<br>
коллекции - хранятся запросы(можно использовать коллекции (разные) для разных модулей ПО)<br>
<br>
- при создании новой коллекции - вкладка "authorisation" дает возможность делать авторизацию при каждом запросе<br>
- pre-request scripts - скрипты, которые отрабатываются до отправки запроса<br>
-tests - атотесты, написаннфе на JavaScript<br>
- variables(переменные)<br>
В коллекциях можно создавать папки (get,post -запросы)<br>
<br>
url - ресурс - ?(через знак вопроса) ... (квер  параметры(params))   - это запрос<br>
приходит тело респонса - это ответ<br>
<br>
post-запрос - должно быть body ,иначе запрос не пройдет(registration(raw,json))<br>
<br>
запуск всех запросов коллекции - зайти в коллекцию -run<br>
можно выбрать порядок исполнения запросов <br>
итерация - количество выполнений запросов<br>
задержка - если серверу нужно время для исполнения post запроса<br>
можно добавить csv файл<br>
<br>
переменная (коллекция - edit -variables) , делаем по 1 переменной за раз<br>
чтобы не писать каждый раз url можно сохранить его в переменную "N" {{N}} (можно использовать для параметров)<br>
<br>
environment(окружение) набор переменных(делается для определенной тимы)<br>
global- используетсядля всего (email,login),доступен всем. Нужно, чтобы сделать много переменных<br>
initial value - общий доступ для тимы<br>
current value - видно только мне<br>
Окружение(шестеренка в правом верхнем углу) <br>
- добавить новое окружение(add,create) <br>
- даем имя окружению(в верхней строчке)<br>
- даем имя в URL окружению(variable)<br>
- даем значение(ссылка) , которое будет использоваться в URL(current value)<br>
- нажимаем add<br>
- выбираем нужный запрос, выбираем нужное окружение<br>
- указываем {{бла}} в URL(переменную, которую создали) <br>
<br>
среды, в которых мы работаем:<br>
dev - где пишут фичи<br>
stage - стабильная версия(код перемещается на stage envinronment , мы работаем с ним, dev это видят)<br>
prod - бэта версия<br>
<br>
автотесты постман:<br>
snippets - шаблоны<br>
встроенные тесты запускаются вместе с запросом,в ремпонсе смотрим test result(pass значит норм)<br>
<br>
создать csv файл:(инфа о переменных)<br>
1.документ txt меняем на csv (эксель файл?)<br>
2.делаем: <br>
login,password<br>
1, abc<br>
2,def<br>
3,gik<br>
3.run collections - select files<br>
4. с помощью notepad++ ставим запятые, чтобы постман увидел значения<br>
5. нужно, чтобы в каждую итерацию использовались отдельные логин и пароль<br>
6. run - post запрос - регим 3 юзеров(3 итерации)<br>
<br>
создать json файл:<br>
1.документ txt меняем на json<br>
2. открываем в notepad++<br>
3.<br>
[<br>
{<br>
"email":...<br>
"password":...<br>
},<br>
{<br>
    "email":...<br>
    "password":...<br>
}<br>
]<br>
4.select file<br>
<br>
csv файл - файл таблицы(эксель),список клиентов интернет-магазина,используется <br>
для сохранения данных\ импорта в интернет-магазин(обмен данными)<br>
 тестирование api невозможно без документации  <br>
 <br>
в get-запросе нет тела(так ничего не передаем на сервер)<br>
в get-запросе видны все параметры в адресной строке. (вся инфа,как часть URL)<br>
в ответе сервера на get-запрос в body содержится html- код вэб страницы или любая инфа, которую мы запросили.<br>
get -запрос может передать инфу на сервер, но это будет небезопасно,т.к. все параметры в видны в URL<br>
в post запросе параметры не видны,т.к. логин и пароль может передавться на сервер, инфа передается в теле запроса.<br>
в постмане можно передать файл вместо текста, указать это можно в параметре.<br>
отправка тела в запросе GET - возможно отклонение запроса<br>
гет - запрос кэшируется,пост - запрос нет <br>
у браузера есть только 1 метод - гет , вбить в адресную строку адрес и получить ресурс<br>
у браузера есть js-интерпретатор, он выполняет js-скрипт код<br>
у браузера есть js -клиент, который умеет выполнять запросы с другими методами<br>
разницы между гет и пост запросом нет, разница в том, что сервер не смотрим в гет запросе <br>
на тело(но лучше сказать на собесе , как обычно: получаем, создаем и т д)<br>
Сервер считывает при запросе:<br>
-метод с адресом <br>
-хедеры<br>
-если гет метод, то тело не считывает<br>
-если пост метод , считывает тело<br>
<br>
Тестирование бэка через постман(Чтобы постман обращался к общему доступу, а не к локалке)<br>
- нажимаем на коллекцию<br>
- переходим в переменные <br>
- снимаем галочку с {{API URL}}.loc  (локалка)<br>
- где обычный IP оставляем галочку (общий доступ)<br>
<br>
Можно импортировать\экспортировать коллекцию в постман <br>
файлом.json или ссылкой на коллекцию. <br>
<br>
Установка авторизации перед запросом<br>
(установка значения для логина и пароля пользователя без запроса на логин)<br>
Авторизация через  Username и Password:<br>
- Берем запрос, заходим во вкладку “Authorization”.<br>
- В левой части окна выбираем “Basic Auth”, в правой указываем Username и Password.<br>
- Жмем “Preview Request”, получившийся token подставится во вкладку Headers и будет доступен. <br>
- Теперь во всех запросах этой коллекции будет предустановлен <br>
полученный token при предавторизации.<br>
<br>
Авторизация через токен:<br>
-Делаем отдельный Login запрос и получаем токен<br>
-Копируем токен и в любом другом запросе во вкладке Authorization выбираем — <br>
bearer token, справа вводим скопированный токен <br>
<br>
<br>
<br>
3.Отправляем данные(заполняем body) в form-data  без  " "  ( key и value всегда без " ")<br>
http://45.141.79.147/api/get-company-images/22  ( в доке эндпойнт указан, как {id}, в постмане  22)<br>
метод get-partners       bearer token        284|U89sRQQkFDUrYU0GSF8X9SsVKv7h1FCpriAYeiDq  {"0":"2","1":"3"} (такой формат ввода в  value)<br>
<br>
В контексте поиска по карте:<br>
Метод сперва возвращает данные по местоположению пользователя <br>
Потом возвращает данные по заведениям на карте рядом и отображает их на карте<br>
<br>
Статус онлайн \ офлайн:<br>
При каждом запросе пользователя это отмечается в таблице (время запроса этого юзера)<br>
Если не было запроса более 5 минут, то статус оффлайн.<br>
<br>
Если делаем запрос через постман: <br>
1.логинемся через логин и пароль <br>
2.получаем токен авторизации<br>
3.используем его для предавторизации и после используем запрос, который хотим<br>
<br>
токен создается при авторизации и хранится в браузере у клиента и при каждом запросе отправляется на сервер в хедерах, чтобы каждый раз не логиниться <br>
jwt это токен авторизации <br>
<br>
<b>Комментарий:</b><br>
-В постмане мы можем видоизменять запрос для тестов<br>
- interceptor postman - расширение для хрома, чтобы постман мог захватывать https<br>
- можем изменить запрос на сервер и посмотреть , как тот ответит(для тестирования)<br>
- Fiddler (программа для перехвата и анализа сетевого траффика)<br>
<br>
<br>
<br>
постман:<br>
можно отправить json-ом в теле запроса , если не проходит в параметрах <br>
ключ-значение(json): ключ это описание,значение нужно ввести(если нет в доке)<br>
воткнуть в заголовки запроса Accept: application/json - тогда будет ответ читабелен, что не так <br>
<br>
json:<br>
{ <br>
"query": "Виктор Иван", <br>
"count": 7 <br>
}<br>
атрибуты в теле ответа в постмане это по сути элементы фронта?<br>
<br>
для тестов сокетов нужен канал , событие, данные <br>
<br>
patch(аналог update) - частичное изменение, может быть не идемпотентным<br>
У нас 2 строки: <br>
PUT: если меняем первую строку, то вторая исчезнет, если не указать ее в теле <br>
PATCH: если меняем первую строку, то вторая останется, даже если не указать ее в теле <br>
<br>
201 - Запрос успешно выполнен и в результате был создан ресурс. <br>
204 - тело ответа пустое(данных нет), запрос выполнен успешно(успешная операция), но клиенту не нужно уходить со своей текущей страницы.<br>
ошибка 401 - ошибка аутентификации( нет в бд данные доступа, которые ввел юзер)<br>
ошибка 403 - ошибка авторизации(у юзера нет прав, чтобы просматривать этот ресурс)<br>
ошибка 405 - не тот метод<br>
ошибка 406 - сервер не может вернуть ответ.Заголовки,формат\кодировка страницы не те,проблема со стороны сайта обычно<br>
ошибка 413  - файл, который вы пытаетесь загрузить на сервер слишком большой для заданной конфигурации сервера.<br>
ошибка 415  - формат содержимого не поддерживается сервером.<br>
<br>
бэк нужен чтобы обработать запрос со фронта и вернуть ответ(возможно без данных)<br>
обращение бэка к бд тоже запрос<br>
<br>
в посте данные шифруются<br> 
в гет нет <br>
<br>
негативные тесты апи - не те параметры, не то тело, не тот метод <br>
<br>
мок-сервис(заглушка) -  «локальная копия» удаленного сервиса, во время тестов своему приложению мы говорим ходить на мок-сервер, а не на удаленный сервер<br>
Мы как бы создаем у себя аналог удаленного веб-сервиса, который отвечает на вызовы нашего приложения.<br>
Виды объектов, которые позволяют симулировать поведение реальных объектов во время тестирования: <br>
Dummy — пустые объекты, передаются в вызываемые методы, но не используются. Предназначены лишь для заполнения параметров методов.<br>
Fake — объекты, которые имеют реализации, но в таком виде, который делает их неподходящими для использования в рабочей ситуации.<br>
Stub —  предоставляют заранее заготовленные ответы на вызовы во время теста и не отвечают ни на какие другие вызовы, которые не требуются в тесте. <br>
Mock — объекты, которые заменяют реальный объект в условиях теста и позволяют проверять вызовы своих методов. <br>
Содержат заранее подготовленные описания вызовов, которые они ожидают получить. <br>
Применяются в основном для тестирования поведения пользователя.<br>
Например:<br>
Есть ответ от сервера { "sum": 20 }, но нам надо, например проверить, что будет отображаться на фронте при  { "sum": 20000 }<br>
Тогда мы ставим такой ответ заглушку { "sum": 20000 } и фронт будет работать с ней, а не с реальными данными сервера. <br>
Этот ответ как бы заглушит реальные данные.<br>
<br>
Создание мок сервера в постмане<br>
-Создаем фиктивный сервак, который по пути, который мы указали будет отдавать ответ, который мы указали в настройках мок-сервера, функционал не вызывает<br>
-Если апи-интерфейс еще не готов, то можно смоделировать ответ сервера, <br>
-Можно тестить клиент сервиса(функционал клиента), когда сам сервис еще не готов<br>
1.new => мок сервер => выставляем метод(гет, пост), путь(test), код(200,401), тело ответа {"req":"get"},{"req":"post"} <br>
=> даем имя серверу =>если передаем сенситив инфу ставим галочку приватный сервак => копируем ip сервака в адресную строку \ заменяем , если нужно переменную юрл в адресной<br> 
строке ip-ком мок сервера\также можно выбрать окужение(имя нашего сервера)<br>
2.через add example можно изменить путь,заголовки, тело запроса, тело ответа(json,xml,raw) и т д(тело ответа,параметры нам предоставляет разраб????)<br>
3.через add example можно добавить много шаблонов<br>
4.если кликнуть на созданную коллекцию, то можно посмотреть логи всех запросов на мок сервер<br>
<br>
Проблемы интеграционного тестирования с внешним АПИ: <br>
1.стабильность тестов - реальный сервак может уйти на обслуживание,может быть перегружен запросами<br>
2.покрытие тестами - Не всегда есть возможность получить некоторые ответы от реального веб-сервиса и смоделировать все рабочие ситуации<br>
3.скорость ответа - сервак может быть перегружен запросами<br>
4.риск работы с реальными данными - есть веб-сервисы, которые позволяют добавлять или изменять данные в удаленной системе.<br>
Методы решения проблемы:<br>
-Тестовый стенд<br>
-свой сервер<br>
-заглушка<br>
-архитектурно<br>
<br>
Подходы к интеграционному тестированию:<br>
-Снизу вверх. Сначала собираются и тестируются модули нижних уровней по отдельности и вместе, после идем все выше и выше по уровням<br>
Модули должны быть готовы на всех уровнях. Модули нижнего уровня - драйвер - модули верхнего уровня<br>
-Сверху вниз. начала собираются и тестируются модули верхних уровней по отдельности и вместе, после идем все ниже и ниже по уровням<br>
Используются заглушки для модулей, которые находятся ниже по уровню, но включение которых в тест еще не произошло.<br>
Модули верхнего уровня - заглушка - модули нижнего уровня<br>
-Большой взрыв. Модули всех уровней собираются и тестируется. <br>
<br>
Этапы интеграционного тестирования:<br>
1.Определить бизнес-процессы: например создание, отмена, приостановка и возобновление подписки, изменение платежной информации для подписки <br>
2.Сделать доку с учетом всех возможных вариаций. Вариации – различные альтернативные выполнения операций(делаем все варианты развития событий)<br>
3.Тест,пошаговое прохождении каждого бизнес-процесса со стартового компонента (где он был инициирован) через все промежуточные и до финального (или финальных) <br>
с проверкой того, что все данные передаются правильно, а ожидаемые события на самом деле случаются.<br>
Комментарий: Понимать структуру продукта, знать, как между собой взаимодействуют все модули.<br>
<br>
Типы взаимодействия интегрированных приложений: <br>
1.обмен файлами(загрузка и выгрузка CSV -файлов )<br>
CSV - Это текстовый файл, в котором содержится информация.<br>
Каждая строка - это отдельная строка таблицы, а столбцы отделены один от другого специальными символами - разделителями (например, запятой).<br>
2.общая база данных<br>
Несколько ПО используют одну БД<br>
минус - отдельные части с трудом поддаются самостоятельной модернизации и замене.<br>
3.удаленный вызов<br>
рест,соап, RPC  - удаленный вызов процедур<br>
если приложению А что-то нужно от приложения Б, то А вызывает функцию приложения Б.<br>
4.асинхронный обмен сообщениями(очереди), синхронный - когда запрос - ответ.<br>
Приложению А необходимо вызвать действие в приложении Б, оно формирует соответствующее сообщение с данными и инструкциями и отправляет <br>
его посредством системы доставки сообщений. «Асинхронный» это: приложение А не должно ждать, пока сообщение дойдет до Б, будет обработано, <br>
сформирован ответ и т д, отправляется сразу следующее сообщение.<br>
Сообщение гарантированно доставляется благодаря механизму очередей сообщений.<br>
Очереди предоставляют буфер для временного хранения сообщений и <br>
конечные точки, которые позволяют подключаться к очереди для отправки и получения сообщений в асинхронном режиме.<br>
В сообщениях могут содержаться запросы, ответы, ошибки и иные данные, передаваемые между программными компонентами. <br>
1 Компонент (Producer) добавляет сообщение в очередь, <br>
где оно будет храниться, пока 2 компонент (Consumer), не извлечет сообщение и не выполнит с ним необходимую операцию.<br>
Плюсы:<br>
-нет потери информации в случае сбоев<br>
-не нужно ждать ответа от сервера<br>
-не будет пиковых нагрузок<br>
метод Pull периодический опрос очереди получателем по поводу наличия новых сообщений;<br>
метод Push — отправку уведомления получателю в момент прихода сообщения. <br>
Метод не требует установления прямой связи между интегрируемыми программамии позволяет поддерживать обмен данными в виде сообщений, <br>
независимо от аппаратной или ОС.Гарантируется, что сообщение не будет потеряно или получено дважды.<br>
Сообщение может передаваться через распределенную систему серверов - менеджеров очередей. <br>
Каждый раз, получая сообщение, менеджер очередей записывает сообщение в локальную очередь, затем передает сообщений по сети другому менеджеру очередей. <br>
посылаемое сообщение не будет удалено из очереди на сервере посылки до тех пор, пока это сообщение не будет полностью принято на сервере - адресате, то есть <br>
реализуется сетевая транзакция при передачи сообщений.<br>
с помощью очередей возможно взаимодействие клиент -сервер<br>
Запросы клиента передаются в виде сообщений в серверную очередь. После обработки запроса приложение-сервер, <br>
отправляет ответ в виде нового сообщения в очередь, указанную клиентом в сообщении-запросе.<br>
При использовании очередей сообщений, нет необходимости, чтобы взаимодействующие приложения были активны одновременно. Программа может отправить сообщение другому приложению,<br> 
которое обработает его, когда сочтет нужным. Отправив сообщение, программа может не ожидать ответа, а продолжать выполнение других задач.<br>
Прикладные программы-публикаторы посылают свою информацию с указанием темы в виде сообщения менеджеру очередей. Другие приложения - подписчики присылают заявки на информацию по темам. <br>
Присланные публикации распределяются между подписчиками через очереди сообщений специальной программой - брокером в соответствии с темами публикаций.<br>
Основными элементами системы очередей сообщений являются:<br>
1.сообщения, которые прикладные программы посылают друг другу;<br>
структура данных, состоящую из заголовка сообщения и прикладных данных (бывают в разных форматах, например xml)<br>
Заголовок содержит контрольную и адресную информацию о сообщении и его характеристиках.<br>
С помощью этой информации менеджер очередей решает, каким образом обрабатывать и куда надо передавать сообщение.<br>
2.очереди, где хранятся сообщения;<br>
Для передачи критически важной информации используется "постоянные" (persistence) сообщения, которые журналируются и восстанавливаются после рестарта менеджера сообщений.<br>
место хранения и обработки сообщений.<br>
3.менеджеры очередей – серверные компоненты, которые управляют очередями и обработкой сообщений;<br>
является главным серверным компонентом и отвечает за управление очередями сообщений и прием вывозов от прикладных программ. <br>
4.каналы передачи сообщений, которые связывают менеджеры очередей между собой.<br>
соединяют менеджеры очередей и позволяют осуществлять направленную посылку сообщений.<br>
очередь DLQ (Dead-Letter Queue) для хранения недоставленных сообщений. это происходит когда очередь, указанная в заголовке сообщения, <br>
не существует или когда очередь назначения оказывается полной.<br>
безопасность: стандартные функции защиты каналов при помощи SSL. <br>
<br>
Два подхода к организации маршрутов взаимодействия интегрируемых систем:<br>
1.прямое взаимодействие интегрированных систем по принципу «каждая с каждой», или «точка-точка». <br>
Интегрированные ПО должны общаться с использованием одинаковых методов взаимодействия и форматов вызовов/данных. <br>
При изменении одного из приложений ( изменение интерфейса взаимодействия данного приложения) приходится модифицировать \перенастраивать все интегрированные с ним системы. <br>
2.взаимодействие через центральный узел; подобную звездообразную архитектуру обычно называемую «хаб + спицы». <br>
Благодаря введению промежуточного звена, уменьшается число связей между приложениями, устраняются прямые связи. <br>
Если меняется одно из интегрированных ПО, то нужно будет модифицировать только одну связь, между данным приложением и хабом.<br>
<br>
</body>
</html>