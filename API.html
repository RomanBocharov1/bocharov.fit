<html>

<head>
<meta charset="utf-8">
</head>
<body>
ВИДЕО REST API<br>
<br>
апи - это официант(посредник)между клиентом(кто пользуется услугами) и кухней (провайдер(сервер) - предосталяет какие-то услуги) <br>
общение идет по контракту, который описывает , как клиент может обращаться к провайдеру, и какие ответы в случае запроса провайдер может дать<br>
апи это интерфейс общения между 2 независимыми компонентами ПО (фронта и бэка \ клиента и сервера )<br>
<br>
xml  -передает документ(xml -документ, + xsd файл + wsdl файл)<br>
json - все остальное <br>
json - короче, быстрее читать и писать<br>
json - состоит из пар: ключ - значение<br>
<br>
<br>
<br>
Виды АПИ:<br>
- открытые(публичные) - любой может использовать(гугл мэпс), к ним можно подключить свой проект бесплатно<br>
- партнерские-нужно заключить договор с компанией, которая владеет этим АПИ, апи является конечным продуктом<br>
- внутренние - не является конечным продуктом,используются для внутреннего использования<br>
<br>
<br>
<br>
рест - архитектурный стиль , строится на принципах:<br>
-унифицированный интерфейс - общие принципы построения путей общения , как осуществляется запрос, какие виды ответов могут быть<br>
(если используется несколько АПИ в приложении )<br>
-клиент-сервер(они обособленны, у каждого свои функции)<br>
-stateless - сервер не хранит клиентскую информацию<br>
когда клиент делает запрос на сервер, то запрос должен содержать все необходимое для того, чтобы сервер мог ответить<br>
Сервер отправляет эти данные на клиент и они сохраняются в cookies, запросом от клиента на сервер отправляются cookies<br>
- ресурс может быть кэширован,если ресурс может быть кеширован, то он должен сообщить об этом клиенту (с помощью хедеров)<br>
- система состоит из слоев, каждый слой не должен знать, что происходит в другом слое, но при этом они должны общаться между собой <br>
- передавать только ту информацию, которую запросил клиент  (загружается не весь сайт, а только страница(ресурс) ,которую запросил клиент)  <br>
- передача данныс с помощью http\https протокола<br>
-Используются разные типы данных для передачи информации(XML,JSON),можно передавать файл или текст <br>
работает на самом высоком уровне, поверх HTTP(надстройка) 
)<br>
-юзер через мобилу, десктоп выходит в интернет делает запрос(на авторизацию)<br>
-апи запрос идет на сервер(апи скрипты в процессе трансформируются в http запрос, который обрабатывается на сервере) , <br>
где осуществляется запрос (селект)в бд, идет проверка есть ли такой юзер в бд <br>
-если такой юзер найден сервер отправляет апи ответ на клиент <br>
<br>
<br>
<br>
SOAP(стандарт) - набор правил, по которым взаимодейсвуют одна программа с другой.<br>
Имеет:<br>
XML(нужен для хранения и передачи данных) - документ, сами данные.<br>
В отличии от HTML(оформление данных) XML это описание данных.Также в отличии от HTML можно добавлять свои тэги.(тэги HTML тоже можно использовать)<br>
XSD-файл - описывает структуру XML - документа и типы данных, которые могут там хранится. xsd:element name="name" type="xsd:string"<br>
WSDL-файл(структура вэб-сервиса) - описывает сообщения, заголовки,события,роуты (не нужна дока)<br>
Использует только XML<br>
Использует все протоколы прикладного уровня(HTTP,FTP,SMTP,DNS и др)<br>
Комментарий:<br>
рест - вызываем функционал исходя из метода и адреса<br>
соап - какой функционал будет выполнен на сервере, зависит от того, что находится в теле (сама операция <br>
находится в теле) - используется пост запрос, т.к. есть тело, мы всегда шлем в теле, что нужно сделать <br>
плюс соапа, что всегда весь список вэб-сервисов прописан файле wsdl (есть список всех запросов)<br>
<br>
<br>
Best practices АПИ<br>
1.эндпойнты  - существительное в ед \ множ числе /users/123, /users/123/car/2<br>
эндпойнт - часть адресной строки, которая идет после порта \users\6 <br>
Можно обращаться к нему разными методами ( \users\6) <br>
2. Использовать корректные методы + не разрешать юзерам использовать ненужные им методы ( в эндпойнте <br>
получения информации с сервера не прописывать возможность POST - метода )<br>
Если нужно что-то добавить, то добавляем еще метод\методы<br>
<br>
3.использование стандартных http-кодов (400, 500 и т д)<br>
4.Валидация - проверка на валидные данные ( на стороне фронта, бэка, бд )<br>
фронт - будет сообщение, что данные невалидны<br>
бек - тест через апи (пример:запрос на максимум\минимум символов, обязательные поля\необязательные - заполнить<br>
 те и другие и затестить, стучимся на адрем которого нет на серваке-возвращает ли 404)<br>
бд - определяется заранее, какие данные могут быть записаны в таблицу(ячейку)<br>
5. отдавать правильный статус код , описывать корректно ошибку <br>
6.всегда думать о безопасности ( https)<br>
аутентификация и авторизация <br>
нужно убедиться , что jwt токен не содержит никаких клиентских данных<br>
ограничение запросов с одного ip(чтобы не было дос атак)<br>
7. документация<br>
<br>
<br>
<br>
Тестирование АПИ<br>
тест апи относится к интеграционному тестированию(блэк бокс или вайт бокс )<br>
Плюсы АПИ Тестирования<br>
- раннее тестирование, до фронта (обычно начинают делать сначала апи и бэк)<br>
- быстрее тесты, чем на ui<br>
- проверка бизнес-логики(валидация и т д )<br>
- автотесты <br>
<br>
<br>
<br>
Процесс тестирование АПИ <br>
тест- план<br>
анализ тестов и тест-дизайн<br>
выполнение тестов <br>
регистрация багов(не те ответы, не та инфа в теле ответа)<br>
<br>
<br>
<br>
Типы тестов АПИ <br>
1.функциональное<br>
- положительные сценарии (валидные данные, верные статус коды, верные ответы в теле, в приложении просходят те изменение которые мы ожидаем)<br>
- негативные сценарии(адекватное реагирование на запросы которые сервер не ожидает, адекватный ответ при падении БД)<br>
2.нефункциональное: <br>
-нагрузочное  - Jmeter, проверка на то , что нет утечки ресурсов, они восстанавливаются после каждого запроса на сервер <br>
-безопасности - не передаем sensitive инфу ы открытом виде, sql иньекции не выполняются на уровне БД<br>
-документации - целевое назначение каждого эндпойнта, какие действия можно совершить, какие методы могут быть использованы, ожидаемые хэдеры,<br>
валидное тело запроса, тело ответа, ответ в случае ошибки.<br>
-регресс<br>
<br>
<br>
<br>
Тестовый сценарий<br>
-базовый позитивный кейс(минимальный набор данных , которые должен содержать запрос)<br>
- расширяем базовый позитивный тест с опциональными параметрами(необязательные поля на фронте)<br>
- негативыне тесты с валиднными данными(повтор уникального имени)<br>
- негативные тесты с невалидными данными<br>
- тест , что может сделать аутентифицированный и авторизированный юзер, и что может сделать неаутен и не авториз юзер(верные статус коды)<br>
- тест безопасности(описано выше)<br>
- тест нагрузочный <br>
- тест документации<br>
<br>
<br>
<br>
Основные проверки АПИ (на уровне каждого теста)<br>
- статус код <br>
- ответ<br>
- хедеры<br>
- время обработки запроса(200-500 мс)<br>
- приложение меняет свое состояние так, как мы ожидали<br>
- безопасность<br>
<br>
<br>
<br>
АПИ имеет свой порт <br>
гет запрос имеет ограничение в 2000 символов, если квери параметры больше 2000 символов , то для получения данных с сервера <br>
можно использовать пост - запрос, тело не имеет ограничений<br>
ошибка 401 - ошибка аутентификации( нет в бд данные доступа, которые ввел юзер)<br>
ошибка 403 - ошибка авторизации(у юзера нет прав, чтобы просматривать этот ресурс)<br>
<br>
<br>
<br>
гет запрос кэширует страницу, которую мы получили с его помощью и при том же запросе берет ее из кэша браузера , это уменьшает нагрузку на сервер,<br> 
чтобы серверу каждый раз не отправлять данные на клиент <br>
<br>
<br>
<br>
<br>
Постман <br>
workspace - хранятся коллекции<br>
коллекции - хранятся запросы(можно использовать коллекции (разные) для разных модулей ПО)<br>
<br>
- при создании новой коллекции - вкладка "authorisation" дает возможность делать авторизацию при каждом запросе<br>
- pre-request scripts - скрипты, которые отрабатываются до отправки запроса<br>
-tests - атотесты, написаннфе на JavaScript<br>
- variables(переменные)<br>
В коллекциях можно создавать папки (get,post -запросы)<br>
<br>
url - ресурс - ?(через знак вопроса) ... (квер  параметры(params))   - это запрос<br>
приходит тело респонса - это ответ<br>
<br>
post-запрос - должно быть body ,иначе запрос не пройдет(registration(raw,json))<br>
<br>
запуск всех запросов коллекции - зайти в коллекцию -run<br>
можно выбрать порядок исполнения запросов <br>
итерация - количество выполнений запросов<br>
задержка - если серверу нужно время для исполнения post запроса<br>
можно добавить csv файл<br>
<br>
переменная (коллекция - edit -variables) , делаем по 1 переменной за раз<br>
чтобы не писать каждый раз url можно сохранить его в переменную "N" {{N}} (можно использовать для параметров)<br>
<br>
environment(окружение) набор переменных(делается для определенной тимы)<br>
global- используетсядля всего (email,login),доступен всем. Нужно, чтобы сделать много переменных<br>
initial value - общий доступ для тимы<br>
current value - видно только мне<br>
Окружение(шестеренка в правом верхнем углу) <br>
- добавить новое окружение(add,create) <br>
- даем имя окружению(в верхней строчке)<br>
- даем имя в URL окружению(variable)<br>
- даем значение(ссылка) , которое будет использоваться в URL(current value)<br>
- нажимаем add<br>
- выбираем нужный запрос, выбираем нужное окружение<br>
- указываем {{бла}} в URL(переменную, которую создали) <br>
<br>
среды, в которых мы работаем:<br>
dev - где пишут фичи<br>
stage - стабильная версия(код перемещается на stage envinronment , мы работаем с ним, dev это видят)<br>
prod - бэта версия<br>
<br>
автотесты постман:<br>
snippets - шаблоны<br>
встроенные тесты запускаются вместе с запросом,в ремпонсе смотрим test result(pass значит норм)<br>
<br>
создать csv файл:(инфа о переменных)<br>
1.документ txt меняем на csv (эксель файл?)<br>
2.делаем: <br>
login,password<br>
1, abc<br>
2,def<br>
3,gik<br>
3.run collections - select files<br>
4. с помощью notepad++ ставим запятые, чтобы постман увидел значения<br>
5. нужно, чтобы в каждую итерацию использовались отдельные логин и пароль<br>
6. run - post запрос - регим 3 юзеров(3 итерации)<br>
<br>
создать json файл:<br>
1.документ txt меняем на json<br>
2. открываем в notepad++<br>
3.<br>
[<br>
{<br>
"email":...<br>
"password":...<br>
},<br>
{<br>
    "email":...<br>
    "password":...<br>
}<br>
]<br>
4.select file<br>
<br>
csv файл - файл таблицы(эксель),список клиентов интернет-магазина,используется <br>
для сохранения данных\ импорта в интернет-магазин(обмен данными)<br>
 тестирование api невозможно без документации  <br>
 <br>
в get-запросе нет тела(так ничего не передаем на сервер)<br>
в get-запросе видны все параметры в адресной строке. (вся инфа,как часть URL)<br>
в ответе сервера на get-запрос в body содержится html- код вэб страницы или любая инфа, которую мы запросили.<br>
get -запрос может передать инфу на сервер, но это будет небезопасно,т.к. все параметры в видны в URL<br>
в post запросе параметры не видны,т.к. логин и пароль может передавться на сервер, инфа передается в теле запроса.<br>
в постмане можно передать файл вместо текста, указать это можно в параметре.<br>
отправка тела в запросе GET - возможно отклонение запроса<br>
гет - запрос кэшируется,пост - запрос нет <br>
у браузера есть только 1 метод - гет , вбить в адресную строку адрес и получить ресурс<br>
у браузера есть js-интерпретатор, он выполняет js-скрипт код<br>
у браузера есть js -клиент, который умеет выполнять запросы с другими методами<br>
разницы между гет и пост запросом нет, разница в том, что сервер не смотрим в гет запросе <br>
на тело(но лучше сказать на собесе , как обычно: получаем, создаем и т д)<br>
Сервер считывает при запросе:<br>
-метод с адресом <br>
-хедеры<br>
-если гет метод, то тело не считывает<br>
-если пост метод , считывает тело<br>
<br>
Тестирование бэка через постман(Чтобы постман обращался к общему доступу, а не к локалке)<br>
- нажимаем на коллекцию<br>
- переходим в переменные <br>
- снимаем галочку с {{API URL}}.loc  (локалка)<br>
- где обычный IP оставляем галочку (общий доступ)<br>
<br>
Можно импортировать\экспортировать коллекцию в постман <br>
файлом.json или ссылкой на коллекцию. <br>
<br>
Установка авторизации перед запросом<br>
(установка значения для логина и пароля пользователя без запроса на логин)<br>
Авторизация через  Username и Password:<br>
- Берем запрос, заходим во вкладку “Authorization”.<br>
- В левой части окна выбираем “Basic Auth”, в правой указываем Username и Password.<br>
- Жмем “Preview Request”, получившийся token подставится во вкладку Headers и будет доступен. <br>
- Теперь во всех запросах этой коллекции будет предустановлен <br>
полученный token при предавторизации.<br>
<br>
Авторизация через токен:<br>
-Делаем отдельный Login запрос и получаем токен<br>
-Копируем токен и в любом другом запросе во вкладке Authorization выбираем — <br>
bearer token, справа вводим скопированный токен <br>
<br>
<br>
<br>
3.Отправляем данные(заполняем body) в form-data  без  " "  ( key и value всегда без " ")<br>
http://45.141.79.147/api/get-company-images/22  ( в доке эндпойнт указан, как {id}, в постмане  22)<br>
метод get-partners       bearer token        284|U89sRQQkFDUrYU0GSF8X9SsVKv7h1FCpriAYeiDq  {"0":"2","1":"3"} (такой формат ввода в  value)<br>
<br>
В контексте поиска по карте:<br>
Метод сперва возвращает данные по местоположению пользователя <br>
Потом возвращает данные по заведениям на карте рядом и отображает их на карте<br>
<br>
Статус онлайн \ офлайн:<br>
При каждом запросе пользователя это отмечается в таблице (время запроса этого юзера)<br>
Если не было запроса более 5 минут, то статус оффлайн.<br>
<br>
Если делаем запрос через постман: <br>
1.логинемся через логин и пароль <br>
2.получаем токен авторизации<br>
3.используем его для предавторизации и после используем запрос, который хотим<br>
<br>
токен создается при авторизации и хранится в браузере у клиента и при каждом запросе отправляется на сервер в хедерах, чтобы каждый раз не логиниться <br>
jwt это токен авторизации <br>
<br>
<b>Комментарий:</b><br>
-В постмане мы можем видоизменять запрос для тестов<br>
- interceptor postman - расширение для хрома, чтобы постман мог захватывать https<br>
- можем изменить запрос на сервер и посмотреть , как тот ответит(для тестирования)<br>
- Fiddler (программа для перехвата и анализа сетевого траффика)<br>
<br>
<br>
<br>
постман:<br>
можно отправить json-ом в теле запроса , если не проходит в параметрах <br>
ключ-значение(json): ключ это описание,значение нужно ввести(если нет в доке)<br>
воткнуть в заголовки запроса Accept: application/json - тогда будет ответ читабелен, что не так <br>
<br>
json:<br>
{ <br>
"query": "Виктор Иван", <br>
"count": 7 <br>
}<br>
атрибуты в теле ответа в постмане это по сути элементы фронта?<br>
<br>
для тестов сокетов нужен канал , событие, данные <br>
<br>
</body>
</html>