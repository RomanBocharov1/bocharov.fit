<html>

<head>
<meta charset="utf-8">
</head>

<body>
Тестирование - процесс испытания ПО у которого 2 цели:<br>
- выявить ситуации, в которых поведение ПО является неправильным<br>
- По соответвует требованиям заказчика<br>
Качество - степень, с которой продукт соответствует ТЗ<br>
Качественный продукт - тот, который прошел валидацию и верификацию.<br>
Верификация - проверка на то, что компоненты системы соответсвуют ТЗ<br>
Валидация - проверка на то, что компоненты системы функционируют соответственно ТЗ<br>
<br>
Пункты тест-плана <br>
0.введение: из чего состоит тест-план<br>
1.История изменений тест плана(если в него вносились правки)<br>
2.Цель тест плана (зачем тест план нужен: описание процесса тестирования, представление о плановых работах)<br>
3.Исходные данные:описание проекта, который тестируем. <br>
4.Компоненты, которые должны тестироваться и которые не должны(отложены на поздние версии)<br>
5.Цели тестирования <br>
-проверка корректной работы всех функций системы на разных версиях браузеров с типовыми сценариями использования, 20% времени на негатив.<br>
-итогом будет заключение командой тестирование о состоянии системы<br>
-результаты текущего покрытия тестами<br>
-занесенные баги в баг-системе<br>
-какое тестирование будет (ручное\авто)<br>
6.Стратегия процесса тестирования<br>
-анализ тз <br>
-функциональноые тесты<br>
-негатив<br>
-кроссбраузерное тестирование<br>
-перетест и регресс <br>
-тест дизайна <br>
-нужные для теста ос и браузеры:список <br>
7.Типы тестирования , инструменты и техники тест дизайна: типы тестов будут применяться для каждого модуля.<br>
8.План работ:дата начала и конца каждого этапа тестирования, нужное время на каждый этап<br>
9.Итог:отчет о проведенном тестировании с описанными багами и рекомендациями с точки зрения юзера<br>
<br>
mock data - фиктивные данные<br>
work around - обходной путь<br>
routing - обработка путей для ссылок(например)<br>
<br>
Архитектура:<br>
Монолит - все модули связаны, при обновлении функционала обновляем систему целиком. <br>
Микросервисы (независимые единицы, у каждого своя БД) - автономные, совместно работающие сервисы, нацеленные на одну работу(задачу)<br>
Можно обновлять функционал отдельном в каждом сервисе, не обновляя целиком систему.<br>
Комментарий:<br>
Сначала можно сделать монолит, после подключить микросервисы. Либо разделить монолит на микросервисы.<br>
<br>
Вэб - сервис(служба)(АПИ): набор протоколов, которые организовывает взаимодействие между  <br>
программами\компонентами программы(т.к. написаны на разных ЯП)<br>
Это интерфейсы обмена данных между приложениями(частями приложения), которые написаны на разных ЯП<br>
(допустим, мы интегрируем курс валют себе на сайт,с помощью REST АПИ<br> 
веб-служба передает информацию о валютах нам на сайт с сайта национального банка )<br>
<br>
Интеграция - организация обмена данных с сервисом - поставщиком данных(работает с помощью API)<br>
<br>
json - java script object notation<br>
<br>
restful - веб-сервис,который отвечает требованиям REST.<br>
<br>
Протокол - набор правил по которым взаимодействует клиент и сервер <br>
<br>
гиперссылка - ведет на сторонний ресурс или нна часть своего своего сайта или публикации.<br>
<br>
BlackBox - тест основан на внешних интерфейсах.Тестируется поведение системы.Доступа к коду нет.<br>
GreyBox (когда есть доступ к апи)- частичный доступ,используются техники черного ящика, но есть также ограниченный доступ к структуре или коду.<br>
Пример: В определенном программном обеспечении пользователю необходимо использовать какое-либо стороннее приложение. <br>
Это приложение, когда оно используется, только его часть предоставляется разработчику. <br>
Итак, теперь это можно проверить только с использованием входных данных и части, которая была раскрыта.<br>
WhiteBox - известен код программы и ее структура.<br>
<br>
Тестовая модель - это модель фукционала, системы или поведения пользователя, которые мы тестируем.<br>
<br>
Фреймворк - набор шаблонов и заготовок (например vue.js)<br>
<br>
Тестовый стенд - это окружение на котором тестируется программа\ билд\ ПО<br>
<br>
DOM - обьектная модель документа, котрую браузер создает в памяти компьютера на основани HTML - кода, <br>
полученного от сервера.<br>
html - корень дерева <br>
head и body - ствол<br>
все остальное ветви<br>
<br>
Валидатор - то, что проверяет документ или информацию на актуальность (поля регистрации)<br>
<br>
Cookies - текстовые файлы на ПК, в которых хранится информация о наших действиях на сайтах. <br>
Менее безопасны,т.к. хранятся на ПК <br>
Бывают временные и постоянные, какой вид куки будет использоваться для разной инфы определяет дев(или владелец сайта)<br>
При заходе на сайт(получении ресурса с сервака) куки отправляется браузером с запросом на сервак<br>
Хранят: <br>
-Данные по входу в аккаунт<br>
-предпочтения пользователей (язык, валюту или размер шрифта)<br>
-товары, которые мы просматривали или добавили в корзину;<br>
-текст, который мы вводили на сайте раньше;<br>
-IP-адрес и местопложение пользователя;<br>
-дату и время посещения сайта;<br>
-версию ОС и браузера;<br>
-клики и переходы.<br>
<br>
Сессия - временной интервал, в течении которого происходит взаимодействие юзера с сайтом и сервак определяет уникального юзера при каждом запросе.<br>
(создается файл на серваке, где хранятся переменные сессии)<br>
- Хранится на сервере<br>
- Через какое-то время происходит автоматический выход(если не было запроса на сервак с id текущей сессии какое-то время)<br>
- Безопаснее ,т.к. сами удаляются<br>
- при сессиях в cookie хранится только id сессии, а вся информация лежит на сервере<br>
- сессия может длится до года<br>
<br>
MVP(minimal viable product) - минимально жизнеспособный продукт<br>
Тестовая версия товара,услуги,сервиса с минимальным набором функций<br>
Тестируем основную функцию, необходимую пользователю\ заказчику<br>
<br>
Домен- адрес сайта в буквенном виде.<br>
www.address.ru<br>
ru -домен 1 уровня (принадлежность к стране\тематическое содержание)<br>
address - домен 2 уровня (уникальное имя в одной доменной зоне)<br>
<br>
Хостинг - аренда места на сервере, где хранятся данные и файлы для функционирования сайта<br>
Хост(единица сети, которая имеет интерфейс) - устройство, которая выполняет функции клиента или сервера<br>
<br>
DNS - система доменных имен <br>
Пользователь набирет адрес сайта(доменное имя) - идет запрос в систему доменных имен(базы находятся у провайдеров) - <br>
она отдает браузеру IP сайта- браузер делает запрос на этот IP - получает ответ от сервера<br>
<br>
state - состояние<br>
<br>
консоль лог (вспомогательный инструмент)<br>
-для проверок<br>
-для логов<br>
-для связи с пользователем <br>
<br>
бэклог<br>
-фичи,которые в планах должны реализованы<br>
-баги, которые откладывают на потом<br>
(из беклога наполняется спринт?)<br>
<br>
DevOps (development + operations) - быстрый выпуск на рынок и гибкое реагирование <br>
на обратную связь от пользователей, быстрое исправление ошибок. (непрерывная интеграция и поставка)<br>
1.Проектирование. <br>
2.Написание кода. <br>
3.Запуск конвейера CI/CD. (непрерывная интеграция и поставка)<br>
4.Тестирование. Непрерывное, автоматическое. После незначительных изменений (добавление новых простых функций)<br>
продукт проходит автотесты и уходит на «боевые» серверы.<br>
5.Развертывание. Непрерывное. Протестированные конфигурации автоматически отправляются на рабочие машины.<br> 
Выпуск и обновления в релиз становятся рутиной: исправление ошибок, тестирование и развертывание происходит по несколько раз в день.<br>
6.Мониторинг. Непрерывный. <br>
На «боевых» серверах к приложению подключаются системы мониторинга, которые могут автоматически отключать неработающие функции,<br>
 оповещать о сбоях и так далее.<br>
 Дев опс настраивает серваки<br>
 <br>
CURL(client url) - инструмент командной строки,для отправки HTTP-запросов.  <br>
Curl поддерживает большое количество протоколов <br>
фронты его используют для отпраки http-запросов к RESTful API. <br>
<br>
placeholder – это подсказка внутри поля формы. Например, <br>
в поле «Пароль» можно вставить подсказку, что нужно ввести «Не менее 6 символов». <br>
 <br>
 Уровни кэширования:<br>
-клиентский<br>
Заголовки HTTP отвечают за определение возможности кэширования ответа <br>
и за определение срока хранения данных. (заголовок Cache-control)<br>
-сетевой<br>
кэш DNS<br>
-серверный<br>
Используется кэш-сервер(прокси) между целевым сервером и клиентом,<br>
чтобы не нагружать сервер одними и теми же запросами.<br>
-уровень приложения<br>
<br>
Геймификация - использование игровых механик в отраслях жизни,не связанных с играми.<br>
<br>
Адаптив - адаптация верстки под разные устройства и разрешения<br>
<br>
Header - шапка сайта , раздел, с которого начинается сайт,содержит логотип, название сайта, форму поиска по сайту и т д  <br>
Каждый раздел может содержать хэдер. <br>
Footer - подвал сайта или раздела веб-страницы, располагается имя автора, дата документа, контактная и правовая информация. <br>
Чтобы определить подвал для сайта, Footer размещают внутри бади. <br>
Можно вставить footer внутрь статьи, чтобы показать дату её публикации.  <br>
<br>
сетевой интерфейс - это сетевая карта в компе<br>
<br>
Хэш(путаница по англ) (криптографическая хеш-функция) - математический алгоритм который делает из массива <br>
данных строку фиксированной длины(40 символов?), состоящую из цифр и букв.(независимо от обьема данных)<br>
Используется для:аутентификацию, проверку целостности данных, защиту файлов и даже обнаружение зловредного ПО.<br>
Например хранение паролей(хранятся в виде хеш-значений,сами пароли не знают сами сервисы, от которых эти пароли(в идеале))<br>
Например антивирусы(пользователь вносит хеш-значение подозрительного файла в базу данных и сравнивает его хеш-значение с <br>
имеющимися там хеш-значениями(так на автомате делает антивирусгая программа))<br>
Например для проверки фальсификации передаваемой инфы: сравнить хеш-значение файла до отправки и после(если хотя бы на 1 один<br>
байт файл будет изменен, то хеш-значение измениться)<br>
 <br>
 ram нужен для хранения данных программ, которые работают в данный момент , копируя в буфер обмена мы сохарняем данные в ram <br>
 <br>
 sql  запрос в бд это то же самое, что и запрос со фронта(событие на фронте) <br>
 запрос через апи это то же самое, что и запрос со фронта (событие на фронте) <br>
 <br>
 комп - сетевая карта - интерфейс сетевой карты - по мак-адресу сетевой карты выдается ip - по ip компы работают друг с другом<br>
 <br>
 CRM  система это по, кот помогает планировать и упорядочить работу с клиентами<br>
 <br>
 агент это программная сущность.способен действовать автономно от имени юзера(торговые боты (получают инфу о товарах))<br>
 <br>
 CMS система/программа, которая организует процесс создания ,редактирования и управления контентом  (конструктор сайта),добавление и изменение страниц <br>
 каталога,настройка тех. параметров под поисковик,использование готовых скриптов для добавление функций сайта    <br>
 <br>
 альфа тест-до передачи юзеру,бета тест - после передачи юзеру<br>
 <br>
 деплой (развертывание) помещение исполняемого кода на сервер (сайт на сервер)<br>
 <br>
 Языки программирования <br>
 низкоуровневые это машинные коды(0-1)<br>
 высокоуровневые это питон,джава,js и т д<br>
 <br>
 <br>
 <br>
 <br>
 Agile   <br>
это набор методов гибкого управления проектами<br>
цель - повышение скорости создания продукта <br>
За счет:<br>
использования итераций(спринтов)<br>
взаимодействия команды<br>
быстрой реакции на изменения<br>
Идеи Agile: <br>
- взаимодействие между людьми<br>
- главная ценность - работающий продукта<br>
- изменение на любом этапе<br>
- документация вторична относительно реально работающего продукта <br>
и сотрудничества между участниками процесса<br>
Спринт - короткий цикл, направленный на выполнение задачи\серии задачи<br>
Итерация: <br>
планирование - проектирование - создание прототипа - тест - обратная связь - запуск<br>
Подходы: <br>
Скрам <br>
- 1-4 недели спринт<br>
В начале спринта обсуждаются цели, в конце спринта результаты<br>
Канбан<br>
Жизненный цикл задачи отображается на канбан-доске(физической, виртуальной)<br>
Визуализация делает процесс открытым<br>
Комментарий: <br>
Waterfall(каскадная модель) - каждый следующий этап начинается после окончания предыдущего.<br>
Тестирование начинается после того, как написан весь код<br>
Если затесалсь ошибка или заказчик захочет внести изменения, то это займет многго времени<br>
<br>
Прокси - сервер: <br>
промежуточный сервер(программа, посредник между клиентом и целевым сервером)<br>
Запрос клиента или ответ сервера может быть изменен в определенных целях(клиент - прокси - www - сервер)<br>
<br>
Аутентификация - используется для подтверждения личности <br>
зарегистрированного пользователя(проверка учетных данных: логин, пароль)<br>
Пользователь в базе уже есть<br>
- однофакторная (sfa) name + password<br>
- двухфакторная (2fa) name + password + код(с телефона\почты)<br>
- многофакторная (mfa) name + password + N-ое количество проверок<br>
1.Клиент логинится <br>
2.С post-запросом на сервер отправляется логин\email\пароль через HTTPS<br>
3.Если логин\email\пароль корректные, создается токен JWT(signing)<br>
4.JWT токен  отправляется на клиент через HTTPS и хранится в браузере у клиента(stateless)<br>
<br>
<br>
Авторизация - после аутентификации авторизация определяет <br>
Степень доступа пользователя к определенным ресурсам(действиям) (какие права имеет)<br>
При запросе на страницу сайта определяется имеет ли пользователь право на доступ к этой странице<br>
1.С помощью GET-запроса JWT(токен) через HTTPS отправляется на сервер<br>
2.Если JWT(токен) валидный, до дается доступ(verifying)<br>
3.Запрашиваемый ресурс через HTTPS отправляется на клиент<br>
<br>
<br>
Cоздание JWT - json web token(signing):<br>
JWT собирается из <br>
1.headers + payload(полезная информация(ID)) <br>
2.secret key (хранится на сервере)  <br>
Они вместе с сигнатурой образуют JWT<br>
JWT отпрвляется на клиент<br>
Комментарий:<br>
JWT - токен авторизации(набор символов)<br>
Когда логинемся сервер проверяет логин и пароль на валидность и отправляет зашифрованный токен на клиент<br>
Клиент сохраняет токен и добавляет его в заголовок каждый раз при запросе  <br>
<br>
<br>
Виды авторизации<br>
Ролевая модель -администратор назначает пользователю одну или несколько ролей, <br>
а уже им выдает доступы(кассир - операции с кассой) <br>
Избирательная модель - права доступа к конкретному объекту выдают конкретному пользователю.<br>
При этом право определять уровень доступа имеет либо владелец конкретного объекта (например, его создатель),<br>
либо суперпользователь (по сути, владелец всех объектов в системе).<br>
Кроме того, пользователь, обладающий определенным уровнем доступа, может передавать назначенные ему права другим.<br>
Например, пользователь А, создав текстовый файл, может назначить пользователю Б права на чтение этого файла, <br>
а пользователю В — права на его чтение и изменение. При этом пользователи Б и В могут передать свои права пользователю Г.<br>
Мандатная модель - администратор назначает каждому элементу системы определенный уровень <br>
доступа. Пользователи получают уровень доступа, определяющий, с какими объектами они могут работать. <br>
Например, в организации может быть пять уровней доступа. Пользователь, имеющий доступ к файлам 3-го уровня,<br>
 может также открывать файлы 1-го и 2-го уровня, но не может работать с файлами 4-го и 5-го уровня.<br>
 <br>
 Дефект - изьян компонента системы(ошибка в коде), который может повлечь за сбой невыполнение функции системы\ ее части.<br>
 Когда ожидаемый результат не равен фактическому.<br>
 Если нашли дефект: <br>
 1.Несколько раз делаем шаги к дефекту, подтверждаем, что есть баг.<br>
 2.Смотрим , что ТЗ не изменилось.<br>
 3.Смотрим нет ли дубликата.<br>
 4.Баг регим в баг-системе(jira)<br>
 5.Делаем баг-репорт<br>
 6.Баг исправляют - тестер перепроверяет - баг закрывают<br>
   Обновление требований -перепроверка бага, что это баг<br>
   Откладывают на другой спринт, если есть более критические баги <br>
   <br>
 Разработчик допускает <b>ошибку</b>b> в написании кода,<b>дефект(баг)</b> затаивается в системе и ждет часа, <br>
 пользователь натыкается на ошибку в коде и происходит <b>сбой</b><br>
 <br>
 Гит<br>
 распределенная система контроля версий, хранит все изменения, можно откатиться до ранней версии<br>
 мастерветка - время,за которое создается ПО<br>
 коммит -изменение на мастер ветке,новый билд, добавление чего в версию по<br>
 бранч - ветка,где дев добавляет изменения в версию, как закончит заливает на мастерветку,где другие девы,тестеры и т д работают с этим<br>
 можно заливать изменения с одного бранча на другой,чтобы девы работали вместе,после залить это на мастерветку<br>
 конфликт - когда 2 дева залили на мастерветку изменения,но 2 кода конфликтуют<br>
 репозиторий- весь проект<br>
 клонирование- можно копировать на локальный комп репозиторий и обратно<br>
 мердж - внести изменения в мастерветку после одобрения,ревью<br>
 клиент - гит ,который установлен на компе.<br>
 гитхаб это сервер,где хранятся все версии по<br>
 vcs ПО для облегчения работы с изменяющей информацией<br>
 github веб сервис для хостинга it проектов и их совместной разработки<br>
 git fetch - склонировать новые коммиты в локальный репозиторий<br>
 git pull - склонировать новые коммиты в сразу на ветку, где работаю(для дева)<br>
 <br>
Логи - документация, где содержится информация о событиях и времени, когда это произошло, ошибках, статистике.<br>
Существуют:<br>
Логи приложения - (браузер, мобильное приложение)<br>
Логи сервера - error logs: информация об ошибках и спец.инфа<br>
             - access logs: общая информация о всех запросах<br>
Системные логи<br>
Уровни логирования: (указываются при запуске программы, зависти от того, что хотим посмотреть,<br>
 т.к если будут выводиться все, то это слишком много информации)<br>
off - не записываются<br>
fatal - блокирующая систему ошибка<br>
error - ошибка, но система работает<br>
warn - предупреждение<br>
info - служебная информация(создания, удаления)<br>
debug - отладка(включает все вышеперечисленное)<br>
trace - все остальное<br>
all - все <br>
Струтура лога:<br>
ip\ время\ тип запроса\ http версия\ код состояния\ ОС\ браузер<br>
Комментарий:<br>
ELK - elastic search logstash (инструмент для анализа логов)<br>
<br>
<br>
<br>
<br>
Квалификация тестировщиков:<br>
testing (tester,qa engineer,software qa engineer,software test engineer) джун?<br>
не отвечает за качество <br>
цель - нахождение багов<br>
<br>
QC(quality control) мидл?<br>
отвечает за качество продукта<br>
контроль качества текущего продукта и сравнение его с ожидаемым результатом<br>
<br>
QA (quality assurance) сеньор?<br>
Гарантия качества<br>
анализ работы тестера и QC. В случае проблем найти их решение <br>
и не дать повлиять на качество продукта<br>
<br>
SDLC (software development life cycle) - жизненный цикл разработки ПО<br>
- процесс, направленный на создание и поддержание работоспособности,качества и надежности ПО<br>
- условная схема, включающач в себя этапы процесса создания ПО<br>
Формальный цикл:<br>
1. Анализ требований<br>
-цели и задачи<br>
-сроки и стоимость<br>
-анализ и формирование требований заказчика<br>
-формирование ТЗ<br>
2.Проектирование<br>
- выбор технологии и ЯП<br>
- требования к UI<br>
- формирование требований к аппаратной части<br>
3.Разработка и реализация <br>
- разработка с помощью технологий и ЯП<br>
- создание прототипарабочей версии продукта<br>
4.Тестирование <br>
-поиск и регистрация багов<br>
- проверка на соответствие ТЗ<br>
5.Релиз и внедрение<br>
- установка системы<br>
- эксплуатация<br>
6. Поддержка <br>
- поддержка пользователей<br>
- исправление багов<br>
- внедрение нового функционала<br>
- изменение существующего функционала<br>
НА ПРАКТИКЕ:<br>
1.клиент звонит в компанию<br>
2.берут заказ <br>
3.пишется ТЗ (ПМ-ом)<br>
4.создается дизайн на основании ТЗ<br>
5.начинает писаться бэк <br>
6.начинает писаться фронт во время этого<br>
7.связка фронта и бэка <br>
8.допиливание фичей <br>
9.выпуск <br>
10.поддержка (новые фичи, изменение текущих фичей и исправление багов)<br>
<br>
STLC (software testing life cycle) - жизненный цикл процесса тестирования<br>
1. Анализ ТЗ<br>
2.Тестовое планирование<br>
- Написание тест-плана<br>
- оценка времени и ресурсов, нужных для тестов<br>
3. чек-листы, тест-кейсы<br>
4. настройка инструментальных средств для тестирования<br>
5. выполнение тестов <br>
-выполнение тестов<br>
-регистрация багов<br>
-перепроверка багов после фикса<br>
6. отчет о тестировании<br>
НА ПРАКТИКЕ:<br>
1.анализ тз и макетов (фигма) <br>
2.тестирование ТЗ на требования(в идеале)<br>
3.тестирование дизайна по тз <br>
4.тестирование АПИ <br>
5.тестирование БД<br>
6.тестирование фронта <br>
7.тестирование связки фронта и бэка <br>
8.тестирование ux<br>
8.допиливание фичей<br>
9.выпуск<br>
10.поддержка (новые фичи, изменение текущих фичей и исправление багов)<br>
Также начиная со связки фронта и бэка мы начинаем тестить все. <br>
<br>
SSL сертификат</b> нужен для создания https соединения между браузером и сервером<br>
его покупают при создании сайта, чтобы данные, которые мы вводим на сайтебыли защищены<br>
CSR - зашифрованный запрос на выпуск SSL - сертификата.<br>
Когда покупаешь SSl сервер формирует открытый и закрытый ключ<br>
<br>
Уровни тестирования: </b><br>
1.Модульное - тест девом, отдельного модуля \ компонента , изолированно от других на соответствие ТЗ<br>
2.Интеграционное <br>
- компонентное: тест работы модулей в связке друг сдругом  <br>
- системное: тест систем друг с другом (программа - вк, фейсбук, тиньков, карты гугл)<br>
3. Системное - тестирование полностью разработанного ПО на всех операцонных системах и браузерах<br>
4.Приемочное -тест проводится заказчиком,что ПО соответствует его требованиям.<br>
<br>
<b>Принципы тестирования:</b> <br>
1.Тестирование демонстрирует наличие дефектов.<br>
2.Исчерпывающее тестирование недостижимо.<br>
3.Раннее тестирование(на уровне требований, начинаем тестировать как можно раньше в цикле SDLC)<br>
4.Скопление дефектов - если пофиксить 1 дефект, то связанные с ним дефекты пофиксятся сами)<br>
5.Парадокс пестицида -одни и те же тесты не находят новых багов(регулярно менять тестовые сценарии)<br>
6.Тестирование зависит от контекста(сайт-визитка или ПО,где важна безопасность тестируются по разному)<br>
7.Фокусировка на функциях продукта и требованиях заказчика.<br>
<br>
1.Функциональное тестирование - что весь функционал, требуемый заказчиком работает.<br>
2.Проверка всех функций ПО, для которого оно сделано.<br>
Нефункциональное тестирование - насколько быстро , стабильно работает система и насколько удобно ей пользоваться.<br>
Пример: <br>
Карандаш  1. пишет ли <br>
          2. удобно ли писать, как долго, какое усилие ломает грифель.<br>
Авторуль  1.ведет ли поворот руля к повороту колес<br>
          2.удобно ли вращать,услие для вращения<br>
          <br>
          <br>
<br>
Тестирование безопасности- защищает ли ситема данные, если да, <br>
то не нарушаетли это ее функциональность.<br>
Принципы:<br>
- конфиденциальность<br>
- целостность ( точная и правильная инфа от отправителя к получателю)<br>
- Аутентификация<br>
- авторизация <br>
- доступность(готовность информации по требованию)<br>
безотказность(отправитель\получатель не получает отказ в отправке\получении информации)<br>
<br>
Исследовательское тестирование - тестирование без тест-сценариев, чек-листов и тест-кейсов.<br>
Можно найти баги, которые не охватывают тест-сценарии.<br>
Делается на основании опыта тестера.<br>
Когда мало времени, нет документации, маленькое ПО.<br>
<br>
Тестирование конфигурации - проверка работы ПО при разных конфигурациях системы(платформы, драйвера,сильный и слабый ПК,ОС,браузеры)<br>
<br>
UNIT-тестинг(модульное тестирование, для программистов)<br>
Тестирование отдельных модулей исходного кода программы.<br>
Цель: Изоляция отдельных частей программы и проверка того, что они работаеют по отдельности.<br>
<br>
Регрессионное тестирование - после изменения билда(добавления нового функционала) <br>
тестируются новые фичи, после этого все то, что уже тестировали до этого.<br>
<br>
Тестирование верстки (верстка - процесс преобразования макета(фигмы), который создает дизайнер в web - страничный вид)<br>
тестируется насколько точен перенос картинки в в web - страничный вид(размер, цвета,отступы, элементы)<br>
дизайнер => верстальщик (HTML,CSS,JS) делает структуры страницы и внешний вид страницы<br>
через devtools смотрим код(CSS)<br>
<br>
SMOKE - тестирование: минимальное количество тестов, тестирование базовых функций билда после каждоой сборки.<br>
<br>
Тестирование взаимодействия - способность системы взаимодействовать с 1 и более компонентами. <br>
Включает в себя тестирование совместимости и интеграционное тестирование. <br>
Способность взаимодействовать с другими системами.<br>
<br>
Sanity - тестирование: проверка работоспособности функции\модуля, <br>
если этот модуль был изменен.(в которой находится эта функция)<br>
<br>
UI - тестирование(графич интерфейса) - тест пользовательского интерфейса, имитация действий юзера.<br>
Клики, кнопки, переходы по ссылкам,чекбоксы, дропдаунбоксы,взаимодейтвие компонентов друг с другом, <br>
все активные элементы верстки.<br>
Функционал соответственно ТЗ.<br>
<br>
Usability - тестирование - степень удобства использования интерфейса.<br>
Насколько удобно воспринимать информацию,ориентриваться на ресурсе, совершать целевые действия.<br>
используется целевая аудитория<br>
<br>
TTD(test driven testing) (для программистов)<br>
-разработка через тестирование<br>
-техника разработки, которая основывается на повторени коротких циклов:<br>
пишется тест, покрывающий желемое изменение<br>
пишется код, котрый позволит пройти тест<br>
<br>
Позитивное тестирование:<br>
тестировнаие по сценарию, кторый соответсвует ожидаемому поведению системы.<br>
Определяем то, что система делает то,для чего и была создана.<br>
Негативное тестирование:<br>
Тестирование по сценарию, который соответствует внештатному поведению системы.(ломаем систему)<br>
Комментарий: Вначале делаем позитивное тестирование, чтобы система работала так, как нужно заказчику, <br>
после уже пытаемся ее сломать, чтобы пофиксить слабые места.<br>
<br>
Тестирование требований:<br>
полнота-все ли описано, функционал,параметры и т д<br>
однозначность - трактовка всеми одинаково.<br>
непротиворечивость - одно требование не должно конфликтовать с другим<br>
необходимость - описываать то, что необходимо<br>
осуществимость - это возможно сделать?<br>
тестируемость - это возможно протестировать?<br>
атомарность - требование нельзя разбить на отдельные требования(дальше разбивать некуда)<br>
модифицируемость - простота внесения изменений в требования<br>
<br>
Performance testing(тестирование производительности)<br>
- производительности(насколько быстро\стабильно работает система \ часть системы под определенной нагрузкой) <br>
1-2 пользователя следуют определенным шагам<br>
- нагрузочное тестирование (поведение системы под нагрузкой)<br>
имитация реальной нагрузки, 1к пользователей<br>
- стресс тестирование (поведение системы под экстремальной нагрузкой)<br>
имитация нагрузки выше предполагаемой, >10к пользователей<br>
<br>
Тестирование надежности - 6 часов подряд тестил ПО.<br>
Тестирование производительности (тест на определение скорости системы при определенной нагрузке)<br>
Android Profiler, запускаем поверх всех программ, запускаем нужный билд и ходим по билду и смотрим на утечки памяти.(как билд грузит систему)<br>
Объект можно назвать утечкой памяти, если он продолжает существовать в памяти даже после того, как на него потеряны все ссылки.  <br>
<br>
Статическое тестирование - без запуска кода <br>
Динамическое тестирование - при запуске кода <br>
<br>
Парсинг - сбор и ситематизация инфы, анализ и сбор инфы для пополения своей бд, копирование статей на сайт.<br>
Пример: мы парсим словарь сравнивая его текст с нужным словом , чтобы найти перевод.<br>
Сбор данных посетителей сайтов, интернет-магазинов и т д - для модели клиента и рекламы. <br>
Взять файл в одном формате и преобразовать его данные в другую форму,HTML-файл с помощью парсинга можно трансформировать в <br>
текст и сделать понятной для человека, конвертировать в JSON и сделать понятной для приложения или скрипта.  <br>
<br>
Сonfluence - свой интернет - портал , возможность дать доступ к нему всем пользователям — для редактирования или для чтения.(общее ЖЖ)<br>
-Хранить проектные документы<br>
-Вести рабочие материалы: протоколы, риски, открытые вопросы<br>
-Информировать участников о правилах, событиях, планах<br>
-Вести всевозможные реестры — задач, бизнес-процессов, разработок <br>
-Раздавать задания и поручения<br>
-Собирать информацию по выполнению задач и поручений<br>
<br>
ADB - отладочный мост андроид<br>
<br>
Интерпретатор - это утилита, которая преобразует написанный код в машинный код.<br>
В браузере встроен движок V8, который преобразует js в машинный код.<br>
<br>
mime types - спецификация для передачи файлов по сети(img,mp3 и т д)<br>
Инициализация - это активация.<br>
<br>
Выражение - это фрагмент кода,который возвращает значение.(в конце концов).Функция тоже возвращает значение.<br>
Вычисление подвыражений будет продолжаться, пока интерпретатор не придет к одному значению.<br>
if, while и for  это инструкции(команды), потому что они только производят и контролируют действия, но не становятся значениями.<br>
<br>
1 бит - принимает одно из двух значений: 0 или 1 <br>
1 байт - 8 бит <br>
1 кб - 1024 байта <br>
1 мб - 1024 кб<br>
1 гб - 1024 мб<br>
1 тб - 1024 гб<br>
<br>
Браузер  — это ПО для компьютера/смартфона, которая позволяет отобразить содержимое сайтов в интернете(содержимое серверов),<br>
загружать файлы на компьютер, управлять виртуальными приложениями.<br>
<br>
Заканчивать тестирование нужно, когда продукт прошел верификацию и валидацию(т.е. считается качественным):<br>
1.Компоненты системы соответсвуют ТЗ<br>
2.Компоненты системы функционируют соответственно ТЗ<br>
<br>
Почему сайт выглядит по разному в разных браузерах:
верстка не соответствует стандартам HTML,CSS;<br>
по-разному интерпретируются значения атрибутов в коде (цвета, шрифты, размеры);<br>
не все методы и свойства js поддерживаются всеми браузерами<br>
<br>
десктоп приложения- те, которые инсталлируем в систему, обновляются юзерами по их желанию<br>
веб-приложения - находятся на наших серверах, мы обновляем их, когда нужно. Основаны на http-протоколе<br>
<br>
метаданные - данные о данных, характеристики описываемых данных<br>
<br>
Прод(продакшн) - окружение для юзеров<br>
<br>
Заголовки содержат описание данных и информацию, необходимую для взаимодействия между клиентом и сервером. <br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
Линукс<br>
ядро это главная программа, основная часть ОС. Ядро выступает в качестве посредника между устройствами ПК <br>
(видеокартой, процессором, оперативной памятью и пр.) и его ПО. <br>
Для этого в коде есть драйверы устройств. Они загружаются в память или подключаются по мере необходимости ресурса <br>
определенного устройства. Ядра управляют устройствами, процессами и памятью, обрабатывают системные вызовы.<br>
На компьютере могут быть запущены сразу несколько программ. <br>
Первые работают в фоновом режиме, вторые ожидают определенных действий от пользователя, <br>
третьи получают информацию из других запущенных программ. Именно ядро распределяет <br>
ресурсы компьютера между всеми программами и организует параллельную работу множества разных процессов.<br>
<br>
Железо — аппаратное обеспечение ПК с его периферийными устройствами.<br>
<br>
Ядро — основной компонент ОС, взаимодействует с аппаратным обеспечением, выступает посредником между низкоуровневым железом <br>
и компонентами верхнего уровня.<br>
<br>
Оболочка — интерфейс для взаимодействия между ядром ОС и пользователями.<br>
<br>
Утилиты — служебные программы, дающие пользователю большую часть функциональных возможностей.<br>
<br>
Системные библиотеки — программы, дающие доступ к функциям ядра. Для выполнения какой-либо задачи ядро вначале получает системный вызов, исходящий от приложений. <br>
Но у каждого ядра свой набор системных вызовов, и они должны понимать формат выполнения задачи. Поэтому программисты разработали стандартную библиотеку процедур, <br>
описывающую набор системных вызовов для конкретной ОС.<br>
<br>
Командная строка линукс (позволяет управлять операционной системой через ввод текста)<br>
cd .. на уровень выше<br>
cd../.. на 2 уровня выше<br>
ls  список фалов в директории<br>
cd сменить директорию<br>
pwd  путь от корня до директории где сейчас<br>
cd- возврат в предыдущую папку<br>
cd ~ домашний каталог<br>
tab автозаполнение имен каталогов<br>
chmod установка прав на папку /файл<br>
mkdir создание новых директорий<br>
grep поиск строки(текста) в файлах <br>
<br>
<br>
<br>
Тестирование локализации + лингвистическое тестирование<br>
-Проверка перевода на нужный язык.<br>
-Соответствие формата даты и времени выбранному региону.<br>
-Форматы для телефонных номеров и адресов.<br>
-Цветовые схемы (один и тот же цвет может иметь разные значения в разных странах).<br>
-Формат валюты.<br>
-Единицы измерения.<br>
-На всех страницах сайта или экранах приложения используется одинаковая терминология.<br>
-Отсутствуют грамматические ошибки.<br>
-Отсутствуют орфографические ошибки.<br>
-Соблюдены правила пунктуации.<br>
-Используется правильное направление текста (справа налево или слева направо).<br>
-Указаны правильные названия торговых марок, городов, мест, должностей и прочее.<br>
-Переносы и разрывы строк на страницах/экранах размещены правильно.<br>
-Длина строк не превышает существующие ограничения <br>
<br>
Метод HTTP является идемпотентным, если ПОВТОРНЫЙ идентичный запрос, <br>
сделанный один или несколько раз подряд, имеет один и тот же эффект, не изменяющий состояние сервера.<br>
GET(получение инфы,состояние сервера не меняется)<br>
PUT(1 раз меняем инфу на сервере, после та же инфа не может измениться 2-й раз на такую же) <br>
DELETE (1-й раз удалит запись, после этого будет код 404)<br>
POST ( НЕидемпотентный,добавит инфу несколько раз)<br>
<br>
IP-адрес роутера это основной шлюз локальной сети<br>
<br>
Отличия десктоп и мобильного тестирования <br>
десктоп<br>
-обнова ставится юзером<br>
мобильное<br>
-обнова ставится владельцем ПО<br>
-вертикальное, горизонтальное расположение экрана <br>
-отображение другое на экране(шторка на экране блокировки и т д )<br>
<br>
<br>
<br>
<br>
<br>
<br>
«Рукопожатие SSL/TLS» - этап установки HTTPS-соединения.<br>
46 по модулю 12 (модуль - кол-во отрезков на электронных часах(часов))<br>
46 оборотов вокруг часов по 12 отрезков(часов) = ответ там, куда попадет конец веревки<br>
3 в степени 29 по модулю 17 = 12 (модуль берется больше 100 чисел, становится сложно вычислить)<br>
но если не знаем степень, то вычислить будет сложно<br>
3- генератор  17 - модуль<br>
<br>
3 в степени 54(выбранное приватное число) по модулю 17 = 15<br>
клиент отправляет 15(публичный ключ) серверу<br>
<br>
3 в степени 24(выбранное приватное число) по модулю 17 = 16<br>
сервер отправляет 16(публичный ключ) клиенту<br>
<br>
клиент берет результат сервера и возводит его в свою степень(приватное число) <br>
16 в степени 54 = 3<br>
 3 по модулю 17 = 1 (секрет кий)<br>
 <br>
сервер берет результат клиента и возводит в свою степень (приватное число) <br>
15 в степени 24 = 3<br>
3 по модулю 17 = 1 (секрет кий)<br>
<br>
публично: генератор(3) и модуль(17), результат с использованием степени = 15 и 16(публичный ключ)<br>
приватно: степень(54 и 24) (приватный ключ)<br>
публичные числа известны<br>
приватные числа неизвестны<br>
Используется: <br>
часовая(модульная) арифметика<br>
дискретное логарифмирование<br>
односторонняя функция: легкая в одну сторону, тяжелая в обратную<br>
<br>
</body>
</html>